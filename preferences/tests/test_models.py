import datetime
import random

from django.contrib.auth import get_user_model
from django.test import TestCase
from django.utils import timezone

from .. import models


class PreferenceTestCase(TestCase):
    def setUp(self):
        # Generate some fake users which will be returned by _fake_user().
        self.users = [
            get_user_model().objects.create(username=f'fake-{n}')
            for n in range(10)
        ]

        # A user with no preferences
        self.no_pref_user = get_user_model().objects.create(username='noprefs')

        # Seed the random number generator to ensure consistency between runs
        random.seed(0xdeadbeef)

        # Create some fake preferences
        self._create_fake_prefeneces()

        # Some common querysets
        self.all_qs = models.Preference.objects.all()
        self.most_recent_qs = models.Preference.objects.all().filter_most_recent_expressed_at()

    def test_preferences_created(self):
        """Some fake preferences are created."""
        self.assertTrue(self.all_qs.exists())

    def test_preferences_created_for_multiple_users(self):
        """Some fake preferences are created for more than one user."""
        self.assertGreater(self.all_qs.values('user').distinct().count(), 0)
        self.assertLessEqual(self.all_qs.values('user').distinct().count(), len(self.users))

    def test_no_pref_user(self):
        """The "no preferences user" has no preferences generated by _create_fake_prefeneces."""
        self._create_fake_prefeneces()
        self.assertFalse(self.all_qs.filter(user=self.no_pref_user).exists())

    def test_most_recent_no_prefs(self):
        """
        The "no preferences user" does not appear in any preferences returned by
        filter_most_recent_expressed_at.

        """
        self.assertFalse(self.most_recent_qs.filter(user=self.no_pref_user).exists())

    def test_most_recent_users(self):
        """
        All users which have a preference appear exactly once in the preferences returned by
        filter_most_recent_expressed_at.

        """
        for user, in self.all_qs.values_list('user').distinct():
            self.assertTrue(self.most_recent_qs.filter(user=user).exists())

    def test_most_recent_for_each_user(self):
        """filter_most_recent_expressed_at returns the most recent preference for each user."""
        for u in self.users + [self.no_pref_user]:
            user_all_qs = self.all_qs.filter(user=u)
            user_recent_qs = self.most_recent_qs.filter(user=u)

            if user_all_qs.exists():
                # Only one preference should be returned for a user
                self.assertEqual(user_recent_qs.count(), 1)
                pref = user_recent_qs.first()

                # Get the most recent preference by conventional query
                most_recent_pref = user_all_qs.order_by('-expressed_at').first()

                # The same preference should be returned
                self.assertEqual(pref.id, most_recent_pref.id)
            else:
                # Expect user_recent_qs to be empty if no user preferences
                self.assertFalse(user_recent_qs.exists())

    def _create_fake_prefeneces(self, n=1000):
        """Create *n* fake preference objects."""
        for _ in range(n):
            self._fake_preference()

    def _fake_preference(self):
        """Create and return a fake user preference."""
        return models.Preference.objects.create(
            user=self._fake_user(),
            allow_capture=random.choice([True, False]),
            request_hold=random.choice([True, False]),
            expressed_at=fake_datetime()
        )

    def _fake_user(self):
        """Return a fake user chosen at random."""
        return random.choice(self.users)


def fake_datetime():
    """
    Generate a random datetime in the past. The date will correspond to some point in the past five
    years.

    """
    max_past = 60*60*24*365.25*5  # seconds in 5 years
    return timezone.now() - datetime.timedelta(seconds=random.randint(1, max_past))
